# Projeto de Introdução à Computação Gráfica 
## Desenvolvido por Gustavo Menezes(Matrícula: 20180136414) e Danilo Henrique(Matrícula: 20170140478)

### Rasterização de Linhas

### Introdução
Este projeto tem  como objetivo desenhar triângulos a partir da rasterização de linhas e para isso foi necessário a implementação de quatro metódos: PutPixel(), DrawLine(), DrawTriangle() e InterpolaCor().

# PutPixel()
Neste primeiro metódo iremos manipular um framebuffer simulado pelo Professor através de um ponteiro(FBptr), onde ele o alocou preenchendo todas suas posições com 0: 


    FBptr = new unsigned char[IMAGE_WIDTH * IMAGE_HEIGHT * 5];
	for (unsigned int i = 0; i < IMAGE_WIDTH * IMAGE_HEIGHT ; i++)
	{
		FBptr[i*4]   = 0;
		FBptr[i*4+1] = 0;
		FBptr[i*4+2] = 0;
		FBptr[i*4+3] = 255;
	}
E a função do PutPixel() seria justamente manipular esse ponteiro para representarmos os pixels. Como cada pixel tem duas coordenadas e uma cor(RGBA), utilizamos essa código para representá-los no framebuffer.

 ![](https://i.imgur.com/mIP7auU.png)

FIGURA 1 - Algoritmo da Struct Color e da função PutPixel().


A variável "pixel" é calculada da seguinte forma: o valor de Y representa a coordenada vertical do pixel, então teríamos que multiplica-lá pelo número total de pixels da largura da imagem (512) e por quatro que seria as componentes de cada pixel; e o valor de X representa a componente horizontal do pixel bastando multiplicar por quatro, (porque quatro é o tamanho de cada pixel) para mover o pixel horizontalmente. Somando X e Y, obtemos o valor exato do pixel que queremos representar.
Com isso basta somar um ao índice do ponteiro, para cada compontente do RGBA e modificá-lo pela cor desejada.  

# DrawLine()
Esse metódo tem como objetivo rasterizar uma reta a partir de dois pixels.

Utilizamos como base o Algoritmo de Bresenham, porém o algoritmo funcionava apenas para o **Octante 0**(inclinação entre 0-45°) e tivemos que generaliza-lo para os oito octantes para que fosse possível desenhar todas as retas necessárias para o triângulo.

Os octantes seguem as seguintes condições:


![](https://i.imgur.com/AkpGvnB.jpg)

FIGURA 2 - Representação dos octantes.

### Para o octante 0

Temos que |dx| > |dy| , dy > 0 e dx > 0 se encaixando nas condições do algoritmo de bresenham, com isso basta implementar o código.

![](https://i.imgur.com/PydaiBJ.png) 

FIGURA 3 - Algoritmo generalizado para o Octante 0.

### Para o octante 1

Temos que |dy| > |dx|, dy > 0 e dx > 0, tendo que modificar o algoritmo de bresenham para rasterizar esta reta, então percebemos que bastava trocar o eixo X pelo eixo Y, que seguiria o mesmo padrão do Octante 0.

![](https://i.imgur.com/XnmpsIo.png)

FIGURA 4 - Algoritmo generalizado para o Octante 1.

Como trocamos os eixos, tivemos que troca dx com dy , a condição do while irá ser em relação ao Y e também invertemos os incrementos (Onde se incrementava o X, agora incrementa o Y, e vice versa).

### Para o octante 2

Temos que |dy| > |dx|, dy > 0 e dx < 0, como o dy é maior que o dx, iremos usar como base o código do octante 1 com algumas modificações.

![](https://i.imgur.com/CZh0Sqx.png)

FIGURA 5 - Algoritmo generalizado para o Octante 2.

Para realizar a comparação de dx com dy, e deixá-lo positivo para a realização dos cálculos, tivemos que inverter o sinal do dx. E onde incrementaríamos o X, agora vamos o decrementar. Pelo fato do dx ser negativo.

### Para o octante 3 

Temos que |dx| > |dy|, dy > 0 e dx < 0, pelo fato de dx ser maior que o dy, vamos usar o código do octante 0, com as modificações feitas no octante 2(onde o dx < 0)

![](https://i.imgur.com/dxk2yyS.png)

FIGURA 6 - Algoritmo generalizado para o Octante 3.

Portanto, para os demais octantes segue o mesmo padrão utilizado, quando o dx ser negativo invertemos o sinal do dx e ao invés de incrementar o x, nos decrementamos. Quando o dx > dy usamos como base o octante 0, caso contrário usamos como base o octante 1.

Como resultado:

![](https://i.imgur.com/zDIsGjI.png)

FIGURA 7 - Resultado da implementação do algoritmo.

### DrawTriangle()

Esse método tem como entrada 3 pontos, e sua função é interligá-los através do DrawLine() para formar um triângulo.

![](https://i.imgur.com/K6vUFuR.png)

FIGURA 8 - Função para desenhar o triângulo.

Chamando o DrawTriangle():
	
       
    Color c0;

    c0.r = 255;

	c0.g = 255;

	c0.b = 255;

	c0.a = 120;

    DrawTriangle(0,256,c0,256,0,c0,512,256,c0);


Temos como resultado:

![](https://i.imgur.com/jXESxVq.png)

FIGURA 9 - Resultado obtido.

# InterpolaCor()

Essa função consiste em interpolar as cores de um ponto à outro de maneira suave.
Ela recebe duas cores(final e inicial) e uma valor real, que dar a suavidade na interpolação:

![](https://i.imgur.com/hryNJuL.png)

FIGURA 10 - Função para interpolação de cor.

A cor (c) a ser printada, começa com os mesmos valores da cor inicial(c0), e vai sendo decrementada pela diferença da cor final pela inicial multiplicado pelo delta, que vai ser atualizado a cada loop durante o DrawLine(), da seguinte forma:


    
    i++;  
    delta = ((float)i)/((float)dx);

Onde o denominador sempre irá ser a maior variação(dx ou dy) do octante que está sendo rasterizado a reta;
Dessa forma o delta irá aumentar a cada loop, que vai , cada vez mais, aproximar a cor (c) da cor final(c1).

Na imagem abaixo, o mesmo triangulo da função drawTriangle() usando a interpolação de cores entre os pontos:

![](https://i.imgur.com/6bmJaL1.png)

FIGURA 11 - Triângulo interpolado nas cores azul, vermelho e verde.

# Conclusão

Consideramos positivo o desenvolvimento do trabalho. Uma vez identificado o problema, conduzimos os estudos com o propósito de achar a lógica para os outros octantes, mas quando o padrão entre eles é identificado, fica mais simples de implementar os octantes restantes.

Salientamos a questão da interpolação que tivemos que analisar a lógica dos algoritmos já implementados, e percebemos que tem várias formas de realizar a interpolação entre cores.

Assim, o trabalho possibilita estabelecer a relação funcional entre a teoria e a prática favorecendo de forma didática a aprendizagem.

# Referências

.Disponível em:

.https://johannesca.github.io/cg_t1/

.https://github.com/ThiagoLuizNunes/CG-Assignments/tree/master/cg_framework


### Pipeline Gráfico

# Introdução

O pipeline gráfico compreende a sequência de passos precisos para transformar a matemática/geométrica descrição de uma cena 3D em uma imagem 2D discreta na tela.

O processo do Pipeline gráfico envolve várias matrizes, por isso faremos uma breve explicação das principais matrizes que iremos utilizar. Traremos também o conceito do Espaço Homogêneo, ou seja, como um ponto no espaço euclidiano corresponde no espaço homogêneo.

Neste projeto, iremos implementar o pipeline gráfico usando a linguagem de programação C/C++ e utilizaremos o OpenGL. Com o OpenGL utilizaremos uma biblioteca matemática chamada GLM que facilitará o uso das matrizes e tornará mais fácil as operações entre elas.

# Espaço Homogêneo

Primeiramente, introduziremos o conceito das coordenadas homogêneas, a translação no espaço 3D (x, y, z) por ser uma transformação afim ela não pode ser representada por uma matriz por isso precisaremos do espaço homogêneo. O espaço homogêneo nos permite fazer um cisalhamento no 4D (x, y, z, w) interseccionando a quarta coordenada  (w = 1) e obter nosso objeto 3D transladado. Todas as matrizes que utilizaremos podem ser escritas no espaço homogêneo permitindo a combinação de todas elas. 

# Tipos de Matrizes 3D

# Translação

A translação consiste em pegar um objeto e translada-lo em qualquer um dos três eixos (x, y, z).

![](https://i.imgur.com/uwdJu8z.png)

      Figura 1 - Matriz de translação no espaço homogêneo.

# Rotação

A matriz de rotação nos permite rotacionar nos três eixos (x, y, z). É importante salientar que a rotação deve ser feita na origem, caso contrário a rotação sofrerá também uma translação.

![](https://i.imgur.com/DeRyj7Q.png)

                  Figura 2 - Rotação no eixo X.

![](https://i.imgur.com/0l8XLy9.png)

                  Figura 3 - Rotação no eixo Y.

![](https://i.imgur.com/0lf3yav.png)

                  Figura 4 - Rotação no eixo Z.

# Escala

A matriz de escala pode mudar o tamanho do objeto e possivelmente sua direção e também a escala pode ser feita nos três eixos (x, y, z).

![](https://i.imgur.com/iR8TU1Q.png)

       Figura 5 - Matriz de escala no espaço homogêneo.

# Processo do Pipeline Gráfico

Agora que temos todas as informações necessárias iremos descrever o que acontece com o objeto em cada parte do processo do Pipeline Gráfico.

![](https://i.imgur.com/8JNoE3l.png)

                Figura 6 - Processo do Pipeline Gráfico.

**Espaço do Objeto -> Espaço do Universo**

No espaço do objeto transformaremos os vértices do objeto através da matriz Model. A matriz model nos permitirá a passagem do espaço do objeto para o espaço do universo, nela conterá translações, rotações e escalas. 

![](https://i.imgur.com/O2LbwrO.png)

    Figura 7 - Espaço do objeto para o Espaço do Universo.

**Matriz Model**

A matriz model conterá a matriz identidade, sua implementação ficará da seguinte forma.

`mat4 Model = mat4(1.0f); `

**Espaço do Universo -> Espaço da Câmera**

Neste processo teremos dois sistemas de coordenadas o do universo e o da câmera. Teremos que definir as informações da câmera sendo elas o UP (coordenada Y), a direção (coordenada z negativa) e para onde a câmera está olhando que seria a origem. E temos que definir uma base ortonormal. Com isso definido utilizaremos a Matriz View para levarmos o objeto para o espaço da câmera.

![](https://i.imgur.com/2o7ydwO.png)

    Figura 8 - Espaço do Universo para o Espaço da Câmera.

![](https://i.imgur.com/GNr45To.png)
    
    Figura 9 - Definindo as informações sobre a câmera.

![](https://i.imgur.com/Gj0hfOy.png)

    Figura 10 - Definindo a base da Câmera.

**Matriz View**

A matriz view conterá a transposta dos vetores da base do espaço da câmera e uma translação caso a origem das coordenadas não sejam compatíveis.

![](https://i.imgur.com/YZoF0FG.png)

        Figura 11 - Definindo a matriz transposta dos vetores da base.

![](https://i.imgur.com/Sr0Hgvn.png)

        Figura 12 - Definindo a matriz de translação.

A implementação da matriz será da seguinte forma.

`mat4 M_view = T * Bt ;`

`mat4 M_model_view = M_view * Model; `

**Espaço da Câmera -> Espaço de Recorte -> Espaço Canônico**

Nesta etapa, utilizaremos a matriz de projeção para passagem do espaço da câmera para o espaço de recorte. No entanto, existe dois tipos de projeções, sendo elas: a projeção perspectiva e a projeção ortogonal. Neste trabalho utilizaremos a projeção perspectiva.

![](https://i.imgur.com/VrxlDfd.png)

    Figura 12 - Projeção paralela e perspectiva, respectivamente.

**Matriz de Projeção**

Definindo a matriz de projeção para causar a distorção perspectiva nos vértices.

![](https://i.imgur.com/lhrhFvs.png)

     Figura 13 - Implementação da matriz de projeção.

Obtendo a matriz model view projection.

`mat4 M_model_view_proj =  M_model_view * M_projection;`

Agora que obtemos a matriz basta aplicar a transformação nos vértices do objeto para irmos para o espaço do recorte. Para ir do espaço do recorte para o espaço canônico, basta dividir todas as coordenadas do vértice por suas respectivas coordenadas w.

![](https://i.imgur.com/IGuOCO8.png)

       Figura 14 - Transformando os vértices do objeto.

![](https://i.imgur.com/IpiNFi4.png)

       Figura 15 - Dividindo as coordenadas dos vértices.

**Espaço Canônico -> Espaço de Tela**

Uma vez no espaço canônico transformaremos os pontos do espaço canônico para o espaço de tela, utilizaremos a matriz View Port para ir para o espaço de tela.

![](https://i.imgur.com/OdjkRQZ.png)

       Figura 16 - Processo do espaço canônico para ir ao espaço de tela.

**Matriz ViewPort**

Construindo a matriz ViewPort

![](https://i.imgur.com/mE4KOjF.png)

        Figura 17 - Matriz ViewPort.

Com a matriz definida podemos aplicar a matriz sobre os vértices e rasterizar as arestas na tela.

![](https://i.imgur.com/G4SF4WE.png)

        Figura 18 - Aplicando a matriz ViewPort nos vértices, 
definindo os pontos a serem ligados e rasterizando as arestas.

![](https://i.imgur.com/DkpOMzO.png)
  
        Figura 19 - Resultado obtido.

Agora generalizamos o algoritmo para carregar qualquer malha. Criamos uma struct onde guardará os vértices e os índices da malha. Com a struct definida, podemos aplicar as transformações em cada vértice do objeto.

![](https://i.imgur.com/IkAk7ST.png)

    Figura 20 - Implementação da Struct.

![](https://i.imgur.com/eCdUodm.png)

    Figura 21 - Aplicando as transformações no objeto em cada processo do Pipeline explicado anteriormente.

![](https://i.imgur.com/HvP82pV.png)

    Figura 22 - Resultado obtido.

**Conclusão**

Consideremos positivo o trabalho pois o algoritmo implementado correspondeu a proposta do trabalho. O projeto também possibilitou um melhor entendimento do processo de transformações do vértice do espaço do objeto até chegar na tela. As dificuldades encontradas foram as multiplicações das matrizes, pois utilizamos a pós-multiplicação e com a utilização da GLM as coordenadas chegavam negativa na tela. 

# Referências

.Disponível em:

.Slides utilizados em sala de aula.

